<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lesson 12: Path Planning</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <div class="container">
        <header class="lesson-header">
            <a href="main.html" class="back-btn">
                <i class="fas fa-arrow-left"></i>
                <span id="back-text">Back</span>
            </a>
            <h1 id="lesson12-full-title">Lesson 12: Path Planning</h1>
        </header>
        
        <main class="lesson-content">
            <div class="explanation-box">
                <h2><i class="fas fa-route"></i> <span id="lesson12-concept-title">Drone Navigation</span></h2>
                <p id="lesson12-concept-text">Drones need to find paths between obstacles. Path planning algorithms help drones navigate forests, cities, or indoor spaces. This is how delivery drones find their way!</p>
                
                <div class="path-algorithms">
                    <div class="algorithm-item">
                        <i class="fas fa-bullseye"></i>
                        <h3>A* Algorithm</h3>
                        <p id="astar-text">Smart search: Finds shortest path around obstacles</p>
                    </div>
                    <div class="algorithm-item">
                        <i class="fas fa-project-diagram"></i>
                        <h3>RRT (Rapidly-exploring Random Tree)</h3>
                        <p id="rrt-text">Random exploration: Good for complex environments</p>
                    </div>
                    <div class="algorithm-item">
                        <i class="fas fa-wave-square"></i>
                        <h3>Potential Fields</h3>
                        <p id="potential-text">Force-based: Obstacles repel, goal attracts</p>
                    </div>
                </div>
                
                <h2><i class="fas fa-list"></i> <span id="lesson12-commands-title">Path Planning Concepts</span></h2>
                <div class="commands-list">
                    <div class="command-item">
                        <code>grid = np.zeros((height, width))</code>
                        <p id="grid-text">Create occupancy grid (0=free, 1=obstacle).</p>
                    </div>
                    
                    <div class="command-item">
                        <code>cv2.line(path_image, start, end, color, thickness)</code>
                        <p id="draw-path-text">Draw path on image for visualization.</p>
                    </div>
                    
                    <div class="command-item">
                        <code>distance = np.sqrt((x2-x1)**2 + (y2-y1)**2)</code>
                        <p id="distance-text">Calculate Euclidean distance between points.</p>
                    </div>
                    
                    <div class="command-item">
                        <code>path = []</code>
                        <p id="path-list-text">Store sequence of points from start to goal.</p>
                    </div>
                </div>
                
                <h2><i class="fas fa-code"></i> <span id="lesson12-example-title">Drone Forest Navigator</span></h2>
                <div class="code-block">
                    <pre><code># Drone Forest Navigator - Path Planning
import cv2
import numpy as np
import heapq
import math
from collections import deque

print("=== Drone Forest Navigator ===")
print("Mission: Plan safe paths through forest obstacles")

class ForestMap:
    def __init__(self, width=600, height=400):
        self.width = width
        self.height = height
        self.grid = np.zeros((height, width), dtype=np.uint8)
        self.trees = []
        
    def add_tree(self, x, y, radius):
        """Add a tree obstacle to the map"""
        self.trees.append((x, y, radius))
        
        # Mark tree area as occupied in grid
        for dy in range(-radius, radius+1):
            for dx in range(-radius, radius+1):
                if dx*dx + dy*dy <= radius*radius:
                    nx, ny = x + dx, y + dy
                    if 0 <= nx < self.width and 0 <= ny < self.height:
                        self.grid[ny, nx] = 1
    
    def add_random_forest(self, num_trees=20):
        """Create random forest with trees"""
        print(f"Creating forest with {num_trees} trees...")
        
        for _ in range(num_trees):
            x = np.random.randint(50, self.width-50)
            y = np.random.randint(50, self.height-50)
            radius = np.random.randint(15, 35)
            self.add_tree(x, y, radius)
        
        print(f"Forest created with {len(self.trees)} trees")
    
    def visualize(self, path=None, start=None, goal=None):
        """Create visualization of map and path"""
        img = np.zeros((self.height, self.width, 3), dtype=np.uint8)
        
        # Draw background (grass)
        img[:] = [100, 150, 50]
        
        # Draw trees
        for x, y, radius in self.trees:
            # Tree trunk
            trunk_height = radius * 2
            cv2.rectangle(img, 
                         (x-5, y), 
                         (x+5, y+trunk_height), 
                         (50, 30, 10), -1)
            # Tree crown
            cv2.circle(img, (x, y), radius, (0, 100, 0), -1)
            cv2.circle(img, (x, y), radius, (0, 50, 0), 2)  # Outline
        
        # Draw start and goal if provided
        if start:
            cv2.circle(img, start, 10, (0, 0, 255), -1)
            cv2.putText(img, 'START', (start[0]-20, start[1]-15),
                       cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0, 0, 255), 2)
        
        if goal:
            cv2.circle(img, goal, 10, (255, 0, 0), -1)
            cv2.putText(img, 'GOAL', (goal[0]-15, goal[1]-15),
                       cv2.FONT_HERSHEY_SIMPLEX, 0.5, (255, 0, 0), 2)
        
        # Draw path if provided
        if path and len(path) > 1:
            for i in range(len(path)-1):
                cv2.line(img, path[i], path[i+1], (255, 255, 0), 2)
            
            # Draw path points
            for point in path:
                cv2.circle(img, point, 3, (255, 200, 0), -1)
        
        return img

class PathPlanner:
    def __init__(self, grid):
        self.grid = grid
        self.height, self.width = grid.shape
    
    def is_free(self, x, y):
        """Check if cell is free (not obstacle)"""
        if 0 <= x < self.width and 0 <= y < self.height:
            return self.grid[y, x] == 0
        return False
    
    def get_neighbors(self, x, y):
        """Get valid neighboring cells (8-direction)"""
        neighbors = []
        for dx in [-1, 0, 1]:
            for dy in [-1, 0, 1]:
                if dx == 0 and dy == 0:
                    continue
                
                nx, ny = x + dx, y + dy
                if self.is_free(nx, ny):
                    # Diagonal movement cost more
                    cost = 1.414 if dx != 0 and dy != 0 else 1
                    neighbors.append(((nx, ny), cost))
        
        return neighbors
    
    def heuristic(self, a, b):
        """Euclidean distance heuristic for A*"""
        return math.sqrt((a[0]-b[0])**2 + (a[1]-b[1])**2)
    
    def a_star(self, start, goal):
        """A* path planning algorithm"""
        print(f"\nA* Search: {start} -> {goal}")
        
        # Priority queue: (f_score, g_score, node, parent)
        open_set = []
        heapq.heappush(open_set, (0, 0, start, None))
        
        # Dictionaries to store costs and parents
        g_score = {start: 0}
        f_score = {start: self.heuristic(start, goal)}
        came_from = {}
        
        nodes_expanded = 0
        
        while open_set:
            current_f, current_g, current, parent = heapq.heappop(open_set)
            
            # Skip if we found a better path to this node
            if current in g_score and current_g > g_score[current]:
                continue
            
            came_from[current] = parent
            nodes_expanded += 1
            
            # Check if we reached goal
            if current == goal:
                # Reconstruct path
                path = []
                while current is not None:
                    path.append(current)
                    current = came_from.get(current)
                path.reverse()
                
                print(f"Path found! Length: {len(path)} nodes")
                print(f"Nodes expanded: {nodes_expanded}")
                print(f"Path cost: {g_score[goal]:.2f}")
                return path
            
            # Explore neighbors
            for neighbor, move_cost in self.get_neighbors(*current):
                tentative_g = g_score[current] + move_cost
                
                if neighbor not in g_score or tentative_g < g_score[neighbor]:
                    g_score[neighbor] = tentative_g
                    f = tentative_g + self.heuristic(neighbor, goal)
                    f_score[neighbor] = f
                    heapq.heappush(open_set, (f, tentative_g, neighbor, current))
        
        print("No path found!")
        return None
    
    def bfs(self, start, goal):
        """Breadth-First Search (simple but not optimal)"""
        print(f"\nBFS Search: {start} -> {goal}")
        
        queue = deque([start])
        visited = {start: None}
        
        while queue:
            current = queue.popleft()
            
            if current == goal:
                # Reconstruct path
                path = []
                while current is not None:
                    path.append(current)
                    current = visited[current]
                path.reverse()
                print(f"BFS path found! Length: {len(path)} nodes")
                return path
            
            # Get neighbors (4-direction for BFS)
            for dx, dy in [(1,0), (-1,0), (0,1), (0,-1)]:
                neighbor = (current[0] + dx, current[1] + dy)
                
                if (self.is_free(*neighbor) and neighbor not in visited):
                    visited[neighbor] = current
                    queue.append(neighbor)
        
        print("BFS: No path found!")
        return None
    
    def potential_field(self, start, goal, obstacles, attractive_gain=0.5, repulsive_gain=1000, repulsive_range=50):
        """Potential field path planning"""
        print(f"\nPotential Field: {start} -> {goal}")
        
        current = np.array(start, dtype=np.float32)
        path = [tuple(current.astype(int))]
        
        max_iterations = 1000
        step_size = 2
        
        for iteration in range(max_iterations):
            # Attractive force (toward goal)
            to_goal = np.array(goal) - current
            dist_to_goal = np.linalg.norm(to_goal)
            
            if dist_to_goal < 5:  # Reached goal
                print(f"Reached goal after {iteration} iterations")
                path.append(goal)
                return path
            
            # Normalize and scale attractive force
            if dist_to_goal > 0:
                attractive_force = attractive_gain * to_goal / dist_to_goal
            else:
                attractive_force = np.zeros(2)
            
            # Repulsive forces (from obstacles)
            repulsive_force = np.zeros(2)
            
            for (ox, oy, radius) in obstacles:
                to_obstacle = current - np.array([ox, oy])
                dist_to_obstacle = np.linalg.norm(to_obstacle)
                
                if dist_to_obstacle < repulsive_range:
                    if dist_to_obstacle > 0:
                        force = (repulsive_gain * 
                                (1/dist_to_obstacle - 1/repulsive_range) *
                                (1/(dist_to_obstacle**2)) *
                                (to_obstacle / dist_to_obstacle))
                        repulsive_force += force
            
            # Total force
            total_force = attractive_force + repulsive_force
            
            # Normalize and apply
            force_magnitude = np.linalg.norm(total_force)
            if force_magnitude > 0:
                total_force = total_force / force_magnitude
            
            # Update position
            current = current + total_force * step_size
            
            # Keep within bounds
            current[0] = max(0, min(self.width-1, current[0]))
            current[1] = max(0, min(self.height-1, current[1]))
            
            # Add to path
            path.append(tuple(current.astype(int)))
            
            # Check for oscillation or stuck
            if len(path) > 10 and path[-1] == path[-5]:
                print(f"Stuck in local minimum after {iteration} iterations")
                break
        
        print(f"Max iterations reached ({max_iterations})")
        return path

def compare_path_algorithms():
    """Compare different path planning algorithms"""
    print("\n=== Comparing Path Planning Algorithms ===")
    
    # Create forest map
    forest = ForestMap(600, 400)
    forest.add_random_forest(25)
    
    # Define start and goal positions
    start = (50, 200)
    goal = (550, 200)
    
    # Check if start and goal are valid
    if not forest.grid[start[1], start[0]] == 0:
        print("Warning: Start position inside obstacle!")
        # Find nearest free cell
        for dx in range(-10, 11):
            for dy in range(-10, 11):
                test_x, test_y = start[0]+dx, start[1]+dy
                if 0 <= test_x < 600 and 0 <= test_y < 400:
                    if forest.grid[test_y, test_x] == 0:
                        start = (test_x, test_y)
                        break
    
    if not forest.grid[goal[1], goal[0]] == 0:
        print("Warning: Goal position inside obstacle!")
        # Find nearest free cell
        for dx in range(-10, 11):
            for dy in range(-10, 11):
                test_x, test_y = goal[0]+dx, goal[1]+dy
                if 0 <= test_x < 600 and 0 <= test_y < 400:
                    if forest.grid[test_y, test_x] == 0:
                        goal = (test_x, test_y)
                        break
    
    print(f"Start: {start}, Goal: {goal}")
    
    # Initialize planner
    planner = PathPlanner(forest.grid)
    
    # Try different algorithms
    algorithms = [
        ("A* Algorithm", planner.a_star),
        ("BFS", planner.bfs),
        ("Potential Field", lambda s, g: planner.potential_field(s, g, forest.trees))
    ]
    
    results = []
    
    for algo_name, algo_func in algorithms:
        print(f"\n--- {algo_name} ---")
        
        import time
        start_time = time.time()
        
        if algo_name == "Potential Field":
            path = algo_func(start, goal)
        else:
            path = algo_func(start, goal)
        
        elapsed = time.time() - start_time
        
        if path:
            path_length = len(path)
            # Calculate actual distance
            if path_length > 1:
                distance = 0
                for i in range(path_length-1):
                    dx = path[i+1][0] - path[i][0]
                    dy = path[i+1][1] - path[i][1]
                    distance += math.sqrt(dx*dx + dy*dy)
            else:
                distance = 0
            
            results.append({
                'name': algo_name,
                'path': path,
                'time': elapsed,
                'length': path_length,
                'distance': distance
            })
            
            print(f"Time: {elapsed:.3f}s")
            print(f"Path nodes: {path_length}")
            print(f"Path distance: {distance:.1f} pixels")
            
            # Visualize
            img = forest.visualize(path, start, goal)
            cv2.imshow(f'{algo_name} Path', img)
            cv2.waitKey(500)
    
    # Compare results
    print("\n" + "="*50)
    print("ALGORITHM COMPARISON")
    print("="*50)
    
    for result in results:
        print(f"\n{result['name']}:")
        print(f"  Time: {result['time']:.3f}s")
        print(f"  Nodes: {result['length']}")
        print(f"  Distance: {result['distance']:.1f}px")
    
    # Create comparison visualization
    comparison_img = np.zeros((400, 600*len(results), 3), dtype=np.uint8)
    
    for i, result in enumerate(results):
        x_offset = i * 600
        algo_img = forest.visualize(result['path'], start, goal)
        comparison_img[0:400, x_offset:x_offset+600] = algo_img
        
        # Add algorithm name
        cv2.putText(comparison_img, result['name'], 
                   (x_offset+10, 30), 
                   cv2.FONT_HERSHEY_SIMPLEX, 1, (255, 255, 255), 2)
        
        # Add statistics
        stats = f"Time: {result['time']:.2f}s  Dist: {result['distance']:.0f}px"
        cv2.putText(comparison_img, stats,
                   (x_offset+10, 70),
                   cv2.FONT_HERSHEY_SIMPLEX, 0.7, (255, 255, 255), 2)
    
    cv2.imshow('Algorithm Comparison', comparison_img)
    
    return results, forest

def interactive_path_planning():
    """Interactive demo for path planning"""
    print("\n=== Interactive Path Planning ===")
    print("\nClick to place obstacles, then set start and goal")
    
    # Create empty map
    width, height = 600, 400
    grid = np.zeros((height, width), dtype=np.uint8)
    
    # Create visualization
    img = np.zeros((height, width, 3), dtype=np.uint8)
    img[:] = [200, 220, 200]
    
    start = None
    goal = None
    obstacles = []
    
    def mouse_callback(event, x, y, flags, param):
        nonlocal start, goal, grid, img
        
        if event == cv2.EVENT_LBUTTONDOWN:
            # Place obstacle (tree)
            radius = 20
            obstacles.append((x, y, radius))
            
            # Update grid
            for dy in range(-radius, radius+1):
                for dx in range(-radius, radius+1):
                    if dx*dx + dy*dy <= radius*radius:
                        nx, ny = x + dx, y + dy
                        if 0 <= nx < width and 0 <= ny < height:
                            grid[ny, nx] = 1
            
            # Draw tree
            cv2.circle(img, (x, y), radius, (0, 100, 0), -1)
            cv2.circle(img, (x, y), radius, (0, 50, 0), 2)
            
            print(f"Obstacle placed at ({x}, {y})")
        
        elif event == cv2.EVENT_RBUTTONDOWN:
            # Set start point
            if grid[y, x] == 0:
                start = (x, y)
                cv2.circle(img, (x, y), 10, (0, 0, 255), -1)
                print(f"Start set at ({x}, {y})")
        
        elif event == cv2.EVENT_MBUTTONDOWN:
            # Set goal point
            if grid[y, x] == 0:
                goal = (x, y)
                cv2.circle(img, (x, y), 10, (255, 0, 0), -1)
                print(f"Goal set at ({x}, {y})")
    
    # Create window and set mouse callback
    cv2.namedWindow('Interactive Path Planning')
    cv2.setMouseCallback('Interactive Path Planning', mouse_callback)
    
    print("\nInstructions:")
    print("• LEFT click: Place tree obstacle")
    print("• RIGHT click: Set start point (red)")
    print("• MIDDLE click: Set goal point (blue)")
    print("• Press 'p': Plan path with A*")
    print("• Press 'c': Clear all")
    print("• Press 'q': Quit")
    
    while True:
        # Display current state
        display = img.copy()
        
        if start:
            cv2.circle(display, start, 10, (0, 0, 255), -1)
            cv2.putText(display, 'START', (start[0]-20, start[1]-15),
                       cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0, 0, 255), 2)
        
        if goal:
            cv2.circle(display, goal, 10, (255, 0, 0), -1)
            cv2.putText(display, 'GOAL', (goal[0]-15, goal[1]-15),
                       cv2.FONT_HERSHEY_SIMPLEX, 0.5, (255, 0, 0), 2)
        
        cv2.imshow('Interactive Path Planning', display)
        
        key = cv2.waitKey(1) & 0xFF
        
        if key == ord('q'):
            break
        
        elif key == ord('p'):
            if start and goal:
                print("\nPlanning path with A*...")
                planner = PathPlanner(grid)
                path = planner.a_star(start, goal)
                
                if path:
                    # Draw path
                    for i in range(len(path)-1):
                        cv2.line(img, path[i], path[i+1], (255, 255, 0), 2)
                    
                    # Draw path points
                    for point in path:
                        cv2.circle(img, point, 3, (255, 200, 0), -1)
                    
                    print(f"Path found with {len(path)} nodes")
                else:
                    print("No path found!")
            else:
                print("Please set both start and goal points first")
        
        elif key == ord('c'):
            # Clear everything
            img[:] = [200, 220, 200]
            grid[:, :] = 0
            start = None
            goal = None
            obstacles = []
            print("\nCleared all!")
    
    cv2.destroyAllWindows()

def real_drone_navigation():
    """Real drone navigation examples"""
    print("\n" + "="*50)
    print("REAL DRONE NAVIGATION APPLICATIONS")
    print("="*50)
    
    print("\n1. DELIVERY DRONES:")
    print("   • Avoid buildings and power lines")
    print("   • Find shortest path to destination")
    print("   • Re-route around obstacles")
    
    print("\n2. SEARCH & RESCUE:")
    print("   • Navigate through disaster areas")
    print("   • Avoid debris and hazards")
    print("   • Cover area efficiently")
    
    print("\n3. AGRICULTURE:")
    print("   • Fly between crop rows")
    print("   • Avoid trees and structures")
    print("   • Optimize spraying patterns")
    
    print("\n4. INSPECTION:")
    print("   • Navigate complex structures")
    print("   • Follow pipes or power lines")
    print("   • Avoid contact with surfaces")
    
    print("\nCode example for delivery drone:")
    print("""
def delivery_drone_navigation(start_gps, goal_gps, obstacle_map):
    # Convert GPS to map coordinates
    start = gps_to_grid(start_gps)
    goal = gps_to_grid(goal_gps)
    
    # Plan path
    planner = PathPlanner(obstacle_map)
    path = planner.a_star(start, goal)
    
    if path:
        # Convert to GPS waypoints
        waypoints = [grid_to_gps(point) for point in path]
        
        # Send to drone
        drone.set_waypoints(waypoints)
        
        return waypoints
    else:
        print("No safe path found!")
        return None
    """)

# Main execution
if __name__ == "__main__":
    print("Starting Drone Path Planning System...")
    
    # Compare algorithms
    results, forest = compare_path_algorithms()
    
    print("\nPress any key for interactive demo...")
    cv2.waitKey(0)
    cv2.destroyAllWindows()
    
    # Interactive demo
    interactive_path_planning()
    
    # Show real applications
    real_drone_navigation()
    
    print("\n" + "="*50)
    print("PATH PLANNING SUMMARY")
    print("="*50)
    
    print("\nAlgorithm recommendations:")
    print("• A*: Best for most applications (optimal and efficient)")
    print("• BFS: Simple, guarantees shortest path in grid")
    print("• Potential Fields: Good for dynamic environments")
    print("• RRT: Best for high-dimensional spaces")
    
    print("\nFor drone applications:")
    print("1. Use A* for pre-planned routes")
    print("2. Combine with obstacle avoidance for runtime")
    print("3. Consider 3D planning for altitude changes")
    
    print("\nPress Enter to exit...")
    input()
    
    print("\n=== Mission Complete ===")
    print("Your drone can now navigate through obstacles!")
    print("Path planning enables autonomous delivery and exploration")</code></pre>
                </div>
                
                <h2><i class="fas fa-keyboard"></i> <span id="lesson12-practice-title">Practice: Create Simple Maze Solver</span></h2>
                <div class="practice-area">
                    <textarea id="code-editor12" placeholder="Try creating a simple maze and solving it with BFS..."></textarea>
                    <div class="practice-buttons">
                        <button class="btn-check" id="check-btn12">
                            <i class="fas fa-check"></i>
                            <span id="check-text">Check Code</span>
                        </button>
                        <button class="btn-clear" id="clear-btn12">
                            <i class="fas fa-eraser"></i>
                            <span id="clear-text">Clear</span>
                        </button>
                    </div>
                    <div id="feedback-message12"></div>
                </div>
                
                <div class="real-life-example">
                    <h3><i class="fas fa-truck-loading"></i> <span id="lesson12-real-title">Amazon Delivery Drones:</span></h3>
                    <p id="lesson12-real-text">Amazon uses A* algorithm for drone deliveries. Drones plan paths avoiding no-fly zones and buildings. Your drone could deliver packages to neighbors using this code!</p>
                </div>
            </div>
            
            <div class="next-lesson">
                <a href="lesson11.html" class="btn-prev">
                    <i class="fas fa-arrow-left"></i>
                    <span id="prev-text">Previous Lesson</span>
                </a>
                <a href="lesson13.html" class="btn-next">
                    <span id="next-text">Next: Geo-Actions</span>
                    <i class="fas fa-arrow-right"></i>
                </a>
            </div>
        </main>
        
        <footer class="footer">
            <button class="btn-change-lang" onclick="window.location.href='index.html'">
                <i class="fas fa-globe"></i>
                <span id="change-lang-text">Change Language</span>
            </button>
            <p></p>
            <p>© Olha Bondarieva</p>
            <p>© Mykhailo Bondariev-Hapon</p>
        </footer>
    </div>
    
    <script src="lang.js"></script>
    <script src="script.js"></script>
    <style>
        .path-algorithms {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }
        
        .algorithm-item {
            text-align: center;
            padding: 20px;
            background: var(--beige);
            border-radius: 10px;
            border-top: 4px solid var(--primary-green);
        }
        
        .algorithm-item i {
            font-size: 2.5rem;
            color: var(--primary-green);
            margin-bottom: 15px;
        }
    </style>
    <script>
        // Добавляем переводы для урока 12
        if (!translations.en['lesson12-full-title']) {
            Object.assign(translations.en, {
                'lesson12-full-title': 'Lesson 12: Path Planning',
                'lesson12-concept-title': 'Drone Navigation',
                'lesson12-concept-text': 'Drones need to find paths between obstacles. Path planning algorithms help drones navigate forests, cities, or indoor spaces. This is how delivery drones find their way!',
                'astar-text': 'Smart search: Finds shortest path around obstacles',
                'rrt-text': 'Random exploration: Good for complex environments',
                'potential-text': 'Force-based: Obstacles repel, goal attracts',
                'lesson12-commands-title': 'Path Planning Concepts',
                'grid-text': 'Create occupancy grid (0=free, 1=obstacle).',
                'draw-path-text': 'Draw path on image for visualization.',
                'distance-text': 'Calculate Euclidean distance between points.',
                'path-list-text': 'Store sequence of points from start to goal.',
                'lesson12-example-title': 'Drone Forest Navigator',
                'lesson12-practice-title': 'Practice: Create Simple Maze Solver',
                'lesson12-real-title': 'Amazon Delivery Drones:',
                'lesson12-real-text': 'Amazon uses A* algorithm for drone deliveries. Drones plan paths avoiding no-fly zones and buildings. Your drone could deliver packages to neighbors using this code!'
            });

            Object.assign(translations.de, {
                'lesson12-full-title': 'Lektion 12: Pfadplanung',
                'lesson12-concept-title': 'Drohnen-Navigation',
                'lesson12-concept-text': 'Drohnen müssen Wege zwischen Hindernissen finden. Pfadplanungsalgorithmen helfen Drohnen, Wälder, Städte oder Innenräume zu navigieren. So finden Lieferdrohnen ihren Weg!',
                'astar-text': 'Intelligente Suche: Findet kürzesten Weg um Hindernisse',
                'rrt-text': 'Zufällige Erkundung: Gut für komplexe Umgebungen',
                'potential-text': 'Kraftbasiert: Hindernisse stoßen ab, Ziel zieht an',
                'lesson12-commands-title': 'Pfadplanungskonzepte',
                'grid-text': 'Belegungsraster erstellen (0=frei, 1=Hindernis).',
                'draw-path-text': 'Pfad auf Bild zeichnen zur Visualisierung.',
                'distance-text': 'Euklidischen Abstand zwischen Punkten berechnen.',
                'path-list-text': 'Punktfolge von Start bis Ziel speichern.',
                'lesson12-example-title': 'Drohnen-Wald-Navigator',
                'lesson12-practice-title': 'Übung: Einfachen Labyrinth-Löser erstellen',
                'lesson12-real-title': 'Amazon-Lieferdrohnen:',
                'lesson12-real-text': 'Amazon nutzt A*-Algorithmus für Drohnenlieferungen. Drohnen planen Pfade, um Flugverbotszonen und Gebäude zu meiden. Deine Drohne könnte mit diesem Code Pakete an Nachbarn liefern!'
            });

            Object.assign(translations.ru, {
                'lesson12-full-title': 'Урок 12: Планирование пути',
                'lesson12-concept-title': 'Навигация дрона',
                'lesson12-concept-text': 'Дронам нужно находить путь между препятствиями. Алгоритмы планирования пути помогают дронам летать в лесах, городах или внутри помещений. Так дроны-доставщики находят дорогу!',
                'astar-text': 'Умный поиск: Находит кратчайший путь вокруг препятствий',
                'rrt-text': 'Случайное исследование: Хорошо для сложной обстановки',
                'potential-text': 'На основе сил: Препятствия отталкивают, цель притягивает',
                'lesson12-commands-title': 'Концепции планирования пути',
                'grid-text': 'Создать карту занятости (0=свободно, 1=препятствие).',
                'draw-path-text': 'Нарисовать путь на изображении для визуализации.',
                'distance-text': 'Вычислить Евклидово расстояние между точками.',
                'path-list-text': 'Сохранить последовательность точек от старта до цели.',
                'lesson12-example-title': 'Навигатор дрона по лесу',
                'lesson12-practice-title': 'Практика: Создать простой решатель лабиринта',
                'lesson12-real-title': 'Дроны доставки Amazon:',
                'lesson12-real-text': 'Amazon использует алгоритм A* для доставки дронами. Дроны планируют путь, избегая запретных зон и зданий. Твой дрон мог бы доставлять посылки соседям с этим кодом!'
            });
        }
        
        document.getElementById('check-btn12')?.addEventListener('click', function() {
            const code = document.getElementById('code-editor12').value;
            const feedback = document.getElementById('feedback-message12');
            
            if (code.includes('deque') || code.includes('heapq') || code.includes('BFS') || code.includes('A*')) {
                feedback.innerHTML = '<i class="fas fa-check-circle success"></i> Excellent! Your drone can now navigate mazes!';
                feedback.className = 'feedback success';
            } else if (code.includes('grid') || code.includes('obstacle')) {
                feedback.innerHTML = '<i class="fas fa-exclamation-circle partial"></i> Good map creation! Now add path finding algorithm.';
                feedback.className = 'feedback partial';
            } else {
                feedback.innerHTML = '<i class="fas fa-times-circle error"></i> Try creating a grid map and using BFS to find path.';
                feedback.className = 'feedback error';
            }
        });
        
        document.getElementById('clear-btn12')?.addEventListener('click', function() {
            document.getElementById('code-editor12').value = '';
            document.getElementById('feedback-message12').innerHTML = '';
            document.getElementById('feedback-message12').className = 'feedback';
        });
    </script>
    <script>
        // Отмечаем урок 12 как пройденный
        markLessonComplete(12);
    </script>
</body>
</html>
